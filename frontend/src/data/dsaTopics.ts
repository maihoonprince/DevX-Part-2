export interface Topic {
  id: string;
  title: string;
  content: string[];
}

export const dsaTopics: Topic[] = [
  {
    id: "arrays",
    title: "Arrays",
    content: [
      "An array is a fundamental data structure that stores elements of the same type in contiguous memory locations.",
      "Key Concepts:",
      "• Arrays are zero-indexed, meaning the first element is at index 0",
      "• Elements can be accessed directly using their index in O(1) time",
      "• Arrays have a fixed size in most programming languages",
      "\nOperations and Time Complexity:",
      "• Access: O(1) - Direct access using index",
      "• Search: O(n) - Linear search in unsorted array",
      "• Insert: O(n) - Need to shift elements",
      "• Delete: O(n) - Need to shift elements",
      "\nCommon Array Patterns:",
      "1. Two Pointer Technique",
      "2. Sliding Window",
      "3. Binary Search (on sorted arrays)",
      "4. Kadane's Algorithm (maximum subarray)",
      "\nPractical Applications:",
      "• Storing and managing collections of similar items",
      "• Implementing other data structures (stacks, queues)",
      "• Matrix operations",
      "• Buffer pools",
    ]
  },
  {
    id: "strings",
    title: "Strings",
    content: [
      "Strings are sequences of characters used to represent text.",
      "Key Concepts:",
      "• Strings are immutable in many languages",
      "• String operations often create new strings",
      "• String comparison and manipulation are common operations",
      "\nCommon String Operations:",
      "1. Concatenation",
      "2. Substring extraction",
      "3. String searching",
      "4. Pattern matching",
      "\nImportant String Algorithms:",
      "• KMP Algorithm (pattern matching)",
      "• Rabin-Karp Algorithm",
      "• String hashing",
      "• Longest Common Subsequence",
      "\nPractical Applications:",
      "• Text processing",
      "• Data parsing",
      "• Regular expressions",
      "• Natural language processing",
    ]
  },
  {
    id: "linked-lists",
    title: "Linked Lists",
    content: [
      "A linked list is a linear data structure where elements are stored in nodes, and each node points to the next node.",
      "Types of Linked Lists:",
      "1. Singly Linked List - Each node has data and a pointer to the next node",
      "2. Doubly Linked List - Each node has data and pointers to both next and previous nodes",
      "3. Circular Linked List - Last node points back to the first node",
      "\nAdvantages:",
      "• Dynamic size",
      "• Easy insertion and deletion",
      "• Flexible memory allocation",
      "\nDisadvantages:",
      "• No random access",
      "• Extra memory for pointers",
      "• Not cache-friendly",
      "\nTime Complexity:",
      "• Access: O(n)",
      "• Search: O(n)",
      "• Insert at beginning: O(1)",
      "• Delete at beginning: O(1)",
      "\nCommon Operations:",
      "• Traversal",
      "• Insertion",
      "• Deletion",
      "• Reversal",
      "• Finding middle element",
      "• Detecting cycles",
    ]
  },
  {
    id: "stacks-queues",
    title: "Stacks & Queues",
    content: [
      "Stacks and Queues are fundamental linear data structures with specific rules for adding and removing elements.",
      "\nStacks:",
      "• LIFO (Last In, First Out) principle",
      "• Operations:",
      "  - Push: Add element to top",
      "  - Pop: Remove element from top",
      "  - Peek: View top element",
      "• Applications:",
      "  - Function call stack",
      "  - Expression evaluation",
      "  - Undo operations",
      "\nQueues:",
      "• FIFO (First In, First Out) principle",
      "• Operations:",
      "  - Enqueue: Add element to rear",
      "  - Dequeue: Remove element from front",
      "  - Front: View front element",
      "• Applications:",
      "  - Process scheduling",
      "  - Print queue",
      "  - Breadth-first search",
      "\nVariations:",
      "• Priority Queue",
      "• Deque (Double-ended queue)",
      "• Circular Queue",
      "\nImplementation Approaches:",
      "1. Array-based implementation",
      "2. Linked list-based implementation",
    ]
  },
  {
    id: "recursion-backtracking",
    title: "Recursion & Backtracking",
    content: [
      "Recursion is a programming concept where a function calls itself to solve a smaller instance of the same problem.",
      "\nKey Concepts of Recursion:",
      "• Base Case: Condition that stops recursion",
      "• Recursive Case: Where function calls itself",
      "• Call Stack: Memory used to track recursive calls",
      "\nBacktracking:",
      "• Problem-solving technique that tries different solutions",
      "• Builds candidates incrementally",
      "• Abandons candidates ('backtracks') when they're invalid",
      "\nCommon Applications:",
      "1. Tree/Graph Traversal",
      "2. Combination Problems",
      "3. Permutation Problems",
      "4. Subset Problems",
      "\nWhen to Use:",
      "• Problems with multiple solutions",
      "• Problems that can be broken into similar sub-problems",
      "• When you need to explore all possibilities",
      "\nCommon Patterns:",
      "• Decision Tree Construction",
      "• State Space Tree",
      "• Pruning techniques",
    ]
  },
  {
    id: "sorting-searching",
    title: "Sorting & Searching",
    content: [
      "Sorting algorithms arrange elements in a specific order, while searching algorithms find elements in a collection.",
      "\nPopular Sorting Algorithms:",
      "1. Bubble Sort:",
      "   • Time: O(n²), Space: O(1)",
      "   • Simple but inefficient",
      "2. Merge Sort:",
      "   • Time: O(n log n), Space: O(n)",
      "   • Divide and conquer approach",
      "3. Quick Sort:",
      "   • Time: O(n log n) average, O(n²) worst",
      "   • In-place sorting",
      "\nSearching Algorithms:",
      "1. Linear Search:",
      "   • Time: O(n)",
      "   • Works on unsorted arrays",
      "2. Binary Search:",
      "   • Time: O(log n)",
      "   • Requires sorted array",
      "\nAdvanced Concepts:",
      "• Sorting stability",
      "• In-place vs. Extra space",
      "• Comparison vs. Non-comparison sorts",
      "• Hybrid sorting algorithms",
    ]
  },
  {
    id: "trees",
    title: "Trees",
    content: [
      "Trees are hierarchical data structures with a root node and child nodes organized in levels.",
      "\nTypes of Trees:",
      "1. Binary Trees:",
      "   • Each node has at most 2 children",
      "   • Perfect, Complete, and Full variations",
      "2. Binary Search Trees (BST):",
      "   • Left subtree < Node < Right subtree",
      "   • Efficient searching: O(log n) average",
      "3. AVL Trees:",
      "   • Self-balancing BST",
      "   • Height difference ≤ 1",
      "\nTree Traversals:",
      "• Pre-order: Root → Left → Right",
      "• In-order: Left → Root → Right",
      "• Post-order: Left → Right → Root",
      "• Level-order: Level by level",
      "\nApplications:",
      "• File systems",
      "• Database indexing",
      "• Expression parsing",
      "• Decision trees",
      "\nAdvanced Tree Concepts:",
      "• Red-Black Trees",
      "• B-Trees",
      "• Trie (Prefix Tree)",
      "• Segment Trees",
    ]
  },
  {
    id: "graphs",
    title: "Graphs",
    content: [
      "Graphs are collections of vertices (nodes) connected by edges, representing relationships between objects.",
      "\nGraph Representations:",
      "1. Adjacency Matrix:",
      "   • 2D array showing connections",
      "   • Space: O(V²)",
      "2. Adjacency List:",
      "   • List of neighbors for each vertex",
      "   • Space: O(V + E)",
      "\nGraph Types:",
      "• Directed vs Undirected",
      "• Weighted vs Unweighted",
      "• Cyclic vs Acyclic",
      "• Connected vs Disconnected",
      "\nGraph Traversals:",
      "1. Breadth-First Search (BFS):",
      "   • Level by level exploration",
      "   • Uses queue",
      "2. Depth-First Search (DFS):",
      "   • Explores as far as possible",
      "   • Uses stack/recursion",
      "\nCommon Algorithms:",
      "• Dijkstra's (shortest path)",
      "• Kruskal's (minimum spanning tree)",
      "• Topological Sort",
      "• Floyd-Warshall (all pairs shortest)",
    ]
  },
  {
    id: "dynamic-programming",
    title: "Dynamic Programming",
    content: [
      "Dynamic Programming (DP) is an optimization technique that solves complex problems by breaking them into simpler subproblems.",
      "\nKey Concepts:",
      "1. Overlapping Subproblems:",
      "   • Same subproblems solved multiple times",
      "   • Solutions can be stored and reused",
      "2. Optimal Substructure:",
      "   • Optimal solution contains optimal subsolutions",
      "\nApproaches:",
      "1. Top-down (Memoization):",
      "   • Recursive approach",
      "   • Cache results in map/array",
      "2. Bottom-up (Tabulation):",
      "   • Iterative approach",
      "   • Build solution from base cases",
      "\nCommon Problems:",
      "• Fibonacci sequence",
      "• Knapsack problem",
      "• Longest Common Subsequence",
      "• Edit Distance",
      "\nProblem-Solving Steps:",
      "1. Identify if DP is applicable",
      "2. Define state and transitions",
      "3. Choose approach (top-down/bottom-up)",
      "4. Optimize space if needed",
    ]
  },
  {
    id: "bit-manipulation",
    title: "Bit Manipulation",
    content: [
      "Bit manipulation involves working with individual bits in numbers to perform operations efficiently.",
      "\nBasic Operations:",
      "• AND (&): 1 if both bits are 1",
      "• OR (|): 1 if either bit is 1",
      "• XOR (^): 1 if bits are different",
      "• NOT (~): Inverts all bits",
      "• Left Shift (<<): Multiply by 2",
      "• Right Shift (>>): Divide by 2",
      "\nCommon Bit Tricks:",
      "1. Check if number is even/odd:",
      "   • n & 1 == 0 (even)",
      "2. Get/Set/Clear bit:",
      "   • Get: (n >> i) & 1",
      "   • Set: n | (1 << i)",
      "   • Clear: n & ~(1 << i)",
      "\nApplications:",
      "• Optimizing space usage",
      "• Fast arithmetic operations",
      "• State representation",
      "• Cryptography",
      "\nPractical Examples:",
      "• Counting set bits",
      "• Power of 2 check",
      "• Finding single number",
      "• Bit masking",
    ]
  }
];
